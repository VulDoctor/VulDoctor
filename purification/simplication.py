import json
from typing import Tuple, Dict, List
import difflib
from tqdm import tqdm
from tree_sitter import Language, Parser

from pygments import lex
from pygments.lexers import get_lexer_by_name


def count_tokens(code, language):
    lexer = get_lexer_by_name(language)
    tokens = list(lex(code, lexer))
    return len(tokens)


def load_tree_sitter_c():
    # 加载C语言的tree-sitter语法
    # Language.build_library(
    #     'build/my-languages.so',
    #     ['vendor/tree-sitter-c']
    # )
    C_LANGUAGE = Language('D:\\Desktop\\VulMaster-main\\codesimplication\\data2\\build\\my-languages.so', 'c')

    # 创建一个解析器并设置语言
    parser = Parser()
    parser.set_language(C_LANGUAGE)

    return parser


def split_function_into_blocks(function_code: str, parser) -> List[str]:
    # 解析代码
    tree = parser.parse(bytes(function_code, "utf8"))

    def get_function_header(node):
        dict_function_header = {}
        if node.type == 'primitive_type':
            dict_function_header['primitive_type'] = function_code[node.start_byte:node.end_byte]
        elif node.type == 'function_declarator':
            dict_function_header['function_declarator'] = function_code[node.start_byte:node.end_byte]
        else:
            for child in node.children:
                dict_function_header.update(get_function_header(child))
        return dict_function_header

    # 遍历AST，找到函数体内的所有顶级语句
    def traverse(node):
        blocks = []
        if node.type == 'compound_statement':
            for child in node.children:
                if child.type in ['{', '}', 'comment', 'preproc_if', 'preproc_ifdef', 'preproc_ifndef', 'preproc_else',
                                  'preproc_elif', 'preproc_endif', 'preproc_define', 'preproc_undef', 'preproc_line',
                                  'preproc_error', 'preproc_pragma', 'preproc_include', 'preproc_include_next',
                                  'preproc_import', 'preproc_if_exists', 'preproc_if_not_exists', 'preproc_defined']:
                    # if child.type in ['{', '}', 'comment']:
                    continue
                start_byte = child.start_byte
                end_byte = child.end_byte
                blocks.append(function_code[start_byte:end_byte])
        else:
            for child in node.children:
                blocks.extend(traverse(child))
        return blocks

    # dict_function_header = get_function_header(tree.root_node)
    blocks = traverse(tree.root_node)
    return blocks


def post_function_filter(post_function, discarded_blocks,parser_c):
    blocks = split_function_into_blocks(post_function, parser_c)
    remaining_blocks = []
    for block in blocks:
        if block in discarded_blocks:
            continue
        else:
            remaining_blocks.append(block)
    return post_function[:post_function.index('{') + 1] + '\n' + ''.join(
        ['\t' + block + '\n' for block in remaining_blocks]) + '}'


def filter_code_blocks(pre_function, post_function, slice_line, parser_c):
    # Split the pre_function into blocks
    blocks = split_function_into_blocks(pre_function, parser_c)
    # print('blocks:', blocks)
    # Initialize a list to store the remaining blocks and discarded blocks
    remaining_blocks = []
    discarded_blocks = []

    # Iterate over each block
    for block in blocks:
        # Split the block into lines
        if '\n' not in block:
            flag = False
            # print('block:', block)
            for line in slice_line:
                if block.replace('\n', '').replace('\t', '').strip() in line:
                    flag = True
            if flag:
                remaining_blocks.append(block)
            else:
                discarded_blocks.append(block)
        else:
            block_lines = block.split('\n')

            # Check if any line number of the block is in slice_line
            flag = False
            for sub_block in block_lines:

                for line in slice_line:
                    if sub_block.replace('\n', '').replace('\t', '').strip() in line:
                        # If a line number of the block is in slice_line, add the block to the remaining blocks
                        flag = True
            if flag:
                remaining_blocks.append(block)
            else:
                # If no line number of the block is in slice_line, add the block to the discarded blocks
                discarded_blocks.append(block)

    # Remove the discarded blocks from the post_function
    # for block in discarded_blocks:
    #     pre_function = pre_function.replace(block, '')
    #     post_function = post_function.replace(block, '')
    # print('discarded_blocks:{}'.format(discarded_blocks))
    post_function_simplify = post_function_filter(post_function, discarded_blocks, parser_c)
    # Join the remaining blocks with '\n\n' and return
    return pre_function[:pre_function.index('{') + 1] + '\n' + ''.join(
        ['\t' + block + '\n' for block in remaining_blocks]) + '}', post_function_simplify


def replace_space(s):
    s = s.replace('\n', ' ').replace('\t', ' ')
    while '  ' in s:
        s = s.replace('  ', ' ')
    return s


def diff(pre, post):
    pre = pre.split('\n')
    post = post.split('\n')
    diff = difflib.ndiff(pre, post)
    return diff


def get_pre_and_post_data(diff):
    pre = []
    post = []
    current_pre = []
    current_post = []
    for line in diff:
        if line.startswith('-'):
            if current_post:  # If we were processing added lines, wrap them up
                post.append('<vul-start>\n' + '\n'.join(current_post) + '\n<vul-end>')
                current_post = []
            current_pre.append(line[2:])  # Remove the '- ' prefix
        elif line.startswith('+'):
            if current_pre:  # If we were processing deleted lines, wrap them up
                pre.append('<vul-start>\n' + '\n'.join(current_pre) + '\n<vul-end>')
                current_pre = []
            current_post.append(line[2:])  # Remove the '+ ' prefix
        elif line.startswith(' '):  # If the line has not changed, add it to pre
            if current_pre:  # If we were processing deleted lines, wrap them up
                pre.append('<vul-start>\n' + '\n'.join(current_pre) + '\n<vul-end>')
                current_pre = []
            pre.append(line[2:])  # Remove the '  ' prefix
    # Wrap up any remaining lines
    if current_pre:
        pre.append('<vul-start>\n' + '\n'.join(current_pre) + '\n<vul-end>')
    if current_post:
        post.append('<vul-start>\n' + '\n'.join(current_post) + '\n<vul-end>')
    return pre, post


if __name__ == '__main__':
    parser_c = load_tree_sitter_c()
    # with open('./wait_for_simplication_only_delete_and_add_with_slice.json', 'r', encoding='utf-8') as f1:
    #     readlines = f1.readlines()
    #     # print(len(readlines))
    #     for line in tqdm(readlines, desc='simplication', ascii=True):
    #         loads = json.loads(line)
    #         # try:
    #         # if loads['diff_line_info']['deleted_lines'] == loads['delete_slice'] and count_tokens(loads['func_before'],
    #         #                                                                                       'c') <= 512:
    #         #     pre_simps, post_simps = loads['func_before'], loads['func']
    #         # else:
    #         pre_simp, post_simp = filter_code_blocks(loads['func_before'], loads['func'], loads['delete_slice'], parser_c)
    #         # except Exception as e:
    #         #     print(loads)
    #         # with open('./error.txt', 'a', encoding='utf-8') as f1:
    #         #     f1.writelines(json.dumps(loads, ensure_ascii=False) + '\n')
    #         loads['pre_function_simplication'] = pre_simp
    #         loads['post_function_simplication'] = post_simp
    #         # print(loads['func_before'], '\n\n', loads['func'], '\n\n')
    #         # print(pre_simp, '\n\n', post_simp)
    #         # print(loads['diff_line_info']['deleted_lines'])
    #         # break
    #         with open('./vul_function_modified_simplication_need_Dynamic_exec.json', 'a', encoding='utf-8') as f2:
    #             f2.writelines(json.dumps(loads, ensure_ascii=False) + '\n')
    #         with open('./vul_function_modified_simplication_need_Dynamic_exec_indent.json', 'a',
    #                   encoding='utf-8') as f3:
    #             f3.writelines(json.dumps(loads, ensure_ascii=False, indent=4) + '\n')

    dict1 = {'cve_id': 'CVE-2018-8809', 'cwe_id': ['CWE-125'], 'cvss_vector': 'AV:N/AC:M/Au:N/C:N/I:N/A:P', 'repo_name': 'radareorg/radare2', 'func': 'static int dalvik_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tint sz = dalvik_opcodes[data[0]].len;\n\tif (!op) {\n\t\treturn sz;\n\t}\n\tmemset (op, \'\\0\', sizeof (RAnalOp));\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->fail = UT64_MAX;\n\top->refptr = 0;\n\top->size = sz;\n\top->nopcode = 1; // Necessary??\n\top->id = data[0];\n\n\tswitch (data[0]) {\n\tcase 0xca: // rem-float:\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x1b: // const-string/jumbo\n\tcase 0x14: // const\n\tcase 0x15: // const\n\tcase 0x16: // const\n\tcase 0x17: // const\n\tcase 0x42: // const\n\tcase 0x12: // const/4\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vB = (data[1] & 0x0f);\n\t\t\tut32 vA = (data[1] & 0xf0) >> 4;\n\t\t\t// op->stackop = R_ANAL_STACK_SET;\n\t\t\top->ptr = -vA; // why\n\t\t\top->val = vA;\n\t\t\tesilprintf (op, "0x%"PFMT64x",v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x01: // move\n\tcase 0x07: // move-object\t\t\n\tcase 0x04: // mov-wide\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vB = (data[1] & 0x0f);\n\t\t\tut32 vA = (data[1] & 0xf0) >> 4;\n\t\t\top->stackop = R_ANAL_STACK_SET;\n\t\t\top->ptr = -vA;\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x02: // move/from16\n\tcase 0x03: // move/16\n\tcase 0x05: // move-wide/from16\n\tcase 0x06: // mov-wide&17\n\tcase 0x08: // move-object/from16\n\tcase 0x09: // move-object/16\n\tcase 0x13: // const/16\n\tcase 0x18: // const-wide\n\tcase 0x19: // const-wide\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tif (len > 2) {\n\t\t\tint vA = (int) data[1];\n\t\t\tut32 vB = (data[3] << 8) | data[2];\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t\top->val = vB;\n\t\t}\n\t\tbreak;\n\tcase 0x0a: // move-result\n\tcase 0x0d: // move-exception\n\tcase 0x0c: // move-result-object\n\tcase 0x0b: // move-result-wide\n\t \t// TODO: add MOVRET OP TYPE ??\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vA = data[1];\n\t\t\tesilprintf (op, "sp,v%d,=[8],8,sp,+=,8", vA);\n\t\t}\n\t\tbreak;\n\tcase 0x1a: // const-string\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tif (len > 2) {\n\t\t\tut32 vA = data[1];\n\t\t\tut32 vB = (data[3]<<8) | data[2];\n\t\t\tut64 offset = R_ANAL_GET_OFFSET (anal, \'s\', vB);\n\t\t\top->ptr = offset;\n\t\t\tesilprintf (op, "0x%"PFMT64x",v%d,=", offset, vA);\n\t\t}\n\t\tbreak;\n\tcase 0x1c: // const-class\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tbreak;\n\tcase 0x85: // long-to-float\n\tcase 0x8e: // double-to-int\n\tcase 0x89: // float-to-double\n\tcase 0x8a: // double-to-int\n\tcase 0x87: // double-to-int\n\tcase 0x8c: // double-to-float\n\tcase 0x8b: // double-to-long\n\tcase 0x88: // float-to-long\n\tcase 0x86: // long-to-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x81: // int-to-long\n\tcase 0x82: // \n\tcase 0x83: // \n\tcase 0x84: // \n\tcase 0x8d: // int-to-byte\n\tcase 0x8f: // int-to-short\n\tcase 0x20: // instance-of\n\t\top->type = R_ANAL_OP_TYPE_CAST;\n\t\tbreak;\n\tcase 0x21: // array-length\n\t\top->type = R_ANAL_OP_TYPE_LENGTH;\n\t\tbreak;\n\tcase 0x44: // aget\n\tcase 0x45: //aget-bool\n\tcase 0x46:\n\tcase 0x47: //aget-bool\n\tcase 0x48: //aget-byte\n\tcase 0x49: //aget-char\n\tcase 0x4a: //aget-short\n\tcase 0x52: //iget\n\tcase 0x58: //iget-short\n\tcase 0x53: //iget-wide\n\tcase 0x56: //iget-byte\n\tcase 0x57: //iget-char\n\tcase 0xea: //sget-wide-volatile\n\tcase 0x63: //sget-boolean\n\tcase 0xf4: //iget-byte\n\tcase 0x66: //sget-short\n\tcase 0xfd: //sget-object\n\tcase 0x55: //iget-bool\n\tcase 0x60: // sget\n\tcase 0x61: // \n\tcase 0x62: //\n\tcase 0x64: // sget-byte\n\tcase 0x65: // sget-char\n\tcase 0xe3: //iget-volatile\n\tcase 0xe4: //\n\tcase 0xe5: // sget\n\tcase 0xe6: // sget\n\tcase 0x54: // iget-object\n\tcase 0xe7: // iget-object-volatile\n\tcase 0xe8: //iget-bool\n\tcase 0xf3: //iget-bool\n\tcase 0xf8: //iget-bool\n\tcase 0xf2: //iget-quick\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\tbreak;\n\tcase 0x6b: //sput-byte\n\tcase 0x6d: //sput-short\n\tcase 0xeb: //sput-wide-volatile\n\tcase 0x4b: //aput\n\tcase 0x4c: //aput-wide\n\tcase 0x4d: // aput-object\n\tcase 0x4e: // aput-bool\n\tcase 0x4f: // \n\tcase 0x5e: //iput-char\n\tcase 0xfc: //iput-object-volatile\n\tcase 0xf5: //iput-quick\n\tcase 0x5c: //iput-bool\n\tcase 0x69: //sput-object\n\tcase 0x5f: //iput-wide\n\tcase 0xe9: //iput-wide-volatile\n\tcase 0xf6: //iput-wide\n\tcase 0xf7: //iput-wide\n\tcase 0x67: //iput-wide\n\tcase 0x59: //iput-wide\n\tcase 0x5a: //iput-wide\n\tcase 0x5b: //iput-wide\n\tcase 0x5d: //iput-wide\n\tcase 0x50: //\n\tcase 0x51: // aput-short\n\tcase 0x68: // sput-wide\n\tcase 0x6a: // sput-boolean\n\tcase 0x6c: // sput-wide\n\tcase 0xfe: // sput\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t{\n\t\t\tut32 vA = (data[1] & 0x0f);\n\t\t\tut32 vB = (data[1] & 0xf0) >> 4;\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x9d:\n\tcase 0xad: // mul-double\n\tcase 0xc8: // mul-float\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* fall through */\n\tcase 0xcd:\n\tcase 0xd2:\n\tcase 0x92:\n\tcase 0xb2:\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\tbreak;\n\tcase 0x7c: // not-int\n\tcase 0x7e: // not-long\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\tbreak;\n\tcase 0xa4: // shr-long\n\tcase 0xba: // ushr-int/2addr\n\tcase 0xe2: // ushr-int\n\tcase 0xa5: // ushr-long\n\tcase 0x9a: // ushr-long\n\tcase 0xc5: // ushr-long/2addr\n\tcase 0xc4: // shr-long/2addr\n\tcase 0xe1: // shr-int/lit8\n\tcase 0x99: // shr-int\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tbreak;\n\tcase 0xaa: // rem-float\n\tcase 0xcf: // rem-double\n\tcase 0xaf: // rem-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0xb4: // rem-int/2addr\n\tcase 0xdc: // rem-int/lit8\n\tcase 0xd4: // rem-int\n\tcase 0xbf: // rem-long/2addr\n\tcase 0x9f: // rem-long\n\tcase 0x94: // rem-int\n\t\top->type = R_ANAL_OP_TYPE_MOD; // mod = rem\n\t\tbreak;\n\tcase 0xd7:\n\tcase 0xd9:\n\tcase 0xda:\n\tcase 0xde:\n\tcase 0xdf:\n\tcase 0x96:\n\tcase 0xc2: // xor-long\n\tcase 0x97: // xor-int\n\tcase 0xa2: // xor-long\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\tbreak;\n\tcase 0xc9: // div-float\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x93: // div-int\n\tcase 0xd3: // div-int/lit16\n\tcase 0xdb: // div-int/lit8\n\tcase 0xce: // div-double\n\tcase 0x9e: // div-double\n\tcase 0xbe: // div-double\n\tcase 0xae: // div-double\n\tcase 0xa9: // div-float\n\tcase 0xb3: // div-int/2addr\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\tbreak;\n\tcase 0x0e: // return-void\n\tcase 0x0f: // return\n\tcase 0x10: // return-wide\n\tcase 0x11: // return-object\n\tcase 0xf1: // return-void-barrier\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->eob = true;\n\t\t//TODO: handle return if(0x0e) {}\xa0else {}\n\t\tif (data[0] == 0x0e) {// return-void\n\t\t\tesilprintf (op, "sp,[8],ip,=,8,sp,+=");\n\t\t} else {\n\t\t\tut32 vA = data[1];\n\t\t\tesilprintf (op, "sp,[8],ip,=,8,sp,+=,8,sp,-=,v%d,sp,=[8]", vA);\n\t\t}\n\t\tbreak;\n\tcase 0x28: // goto\n\t\top->jump = addr + ((char)data[1])*2;\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\top->eob = true;\n\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\tbreak;\n\tcase 0x29: // goto/16\n\t\tif (len > 2) {\n\t\t\top->jump = addr + (short)(data[2]|data[3]<<8)*2;\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\top->eob = true;\n\t\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\t}\n\t\tbreak;\n\tcase 0x2a: // goto/32\n\t\tif (len > 2) {\n\t\t\top->jump = addr + (int)(data[2]|(data[3]<<8)|(data[4]<<16)|(data[5]<<24))*2;\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\top->eob = true;\n\t\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\t}\n\t\tbreak;\n\tcase 0x2c:\n\tcase 0x2b:\n\t\top->type = R_ANAL_OP_TYPE_SWITCH;\n\t\tbreak;\n\tcase 0x2d: // cmpl-float\n\tcase 0x2e: // cmpg-float\n\tcase 0x3f: // cmpg-float // ???? wrong disasm imho 2e0f12003f0f\n\tcase 0x2f: // cmpl-double\n\tcase 0x30: // cmlg-double\n\tcase 0x31: // cmp-long\n\tcase 0x1f: // check-cast\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\tbreak;\n\tcase 0x32: // if-eq\n\tcase 0x33: // if-ne\n\tcase 0x34: // if-lt\n\tcase 0x35: // if-ge\n\tcase 0x36: // if-gt\n\tcase 0x37: // if-le\n\tcase 0x38: // if-eqz\n\tcase 0x39: // if-nez\n\tcase 0x3a: // if-ltz\n\tcase 0x3b: // if-gez\n\tcase 0x3c: // if-gtz\n\tcase 0x3d: // if-lez\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t//XXX fix this better the check is to avoid an oob\n\t\tif (len > 2) {\n\t\t\top->jump = addr + (len>3?(short)(data[2]|data[3]<<8)*2 : 0);\n\t\t\top->fail = addr + sz;\n\t\t\top->eob = true;\n\t\t}\n\t\tbreak;\n\tcase 0xec: // breakpoint\n\tcase 0x1d: // monitor-enter\n\t\top->type = R_ANAL_OP_TYPE_UPUSH;\n\t\tbreak;\n\tcase 0x1e: // monitor-exit /// wrong type?\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\tbreak;\n\tcase 0x6f: // invoke-super\n\tcase 0xfa: // invoke-super-quick\n\tcase 0x70: // invoke-direct\n\tcase 0x71: // invoke-static\n\tcase 0x72: // invoke-interface\n\tcase 0x73: //\n\tcase 0x74: //\n\tcase 0x75: //\n\tcase 0x76: // invoke-direct\n\tcase 0x77: //\n\tcase 0x78: // invokeinterface/range\n\tcase 0xb9: // invokeinterface\n\tcase 0xb7: // invokespecial\n\tcase 0xb8: // invokestatic\n\tcase 0xb6: // invokevirtual\n\tcase 0x6e: // invoke-virtual\n\tcase 0xf0: // invoke-object-init-range\n\tcase 0xf9: // invoke-virtual-quick/range\n\tcase 0xfb: // invoke-super-quick/range\n\t\tif (len > 2) {\n\t\t\t//XXX fix this better since the check avoid an oob\n\t\t\t//but the jump will be incorrect\n\t\t\tut32 vB = len > 3?(data[3] << 8) | data[2] : 0;\n\t\t\top->jump = anal->binb.get_offset (anal->binb.bin, \'m\', vB);\n\t\t\top->fail = addr + sz;\n\t\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\t\t// TODO: handle /range instructions\n\t\t\tesilprintf (op, "8,sp,-=,0x%"PFMT64x",sp,=[8],0x%"PFMT64x",ip,=", addr);\n\t\t}\n\t\tbreak;\n\tcase 0x27: // throw\n\tcase 0xee: // execute-inline\n\tcase 0xef: // execute-inline/range\n\tcase 0xed: // throw-verification-error\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\tbreak;\n#if 0\n\tcase 0xbb: // new\n\tcase 0xbc: // newarray\n\tcase 0xc5: // multi new array\n#endif\n\tcase 0x22: // new-instance\n\tcase 0x23: // new-array\n\tcase 0x24: // filled-new-array\n\tcase 0x25: // filled-new-array-range\n\tcase 0x26: // filled-new-array-data\n\t\top->type = R_ANAL_OP_TYPE_NEW;\n\t\t// 0x1c, 0x1f, 0x22\n\t\tif (len > 2) {\n\t\t\t//int vA = (int) data[1];\n\t\t\tint vB = (data[3] << 8) | data[2];\n\t\t\t// resolve class name for vB\n\t\t\tut64 off = R_ANAL_GET_OFFSET (anal, \'t\', vB);\n\t\t\top->ptr = off;\n\t\t}\n\t\tbreak;\n\tcase 0x00: // nop\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\tbreak;\n\tcase 0x90: // add-int\n\tcase 0x9b: // add-long\n\tcase 0xa6: // add-float\n\tcase 0xac: // add-double\n\tcase 0xb0: // add-int/2addr\n\tcase 0xbb: // add-long/2addr\n\tcase 0xc6: // add-float/2addr\n\tcase 0xcb: // add-double/2addr\n\tcase 0xd0: // add-int/lit16\n\tcase 0xd8: // add-int/lit8\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tbreak;\n\tcase 0xa7: // sub-float\n\tcase 0xcc: //sub-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* fall thru */\n\tcase 0xc7:\n\tcase 0xbc:\n\tcase 0x91:\n\tcase 0xb1: //sub-int/2addr\n\tcase 0xd1: //sub-int/2addr\n\tcase 0x9c: //sub-long\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\tbreak;\n\tcase 0x7b: // neg-int\n\tcase 0x7d: // neg-long\n\tcase 0x7f: // neg-float\n\tcase 0x80: // neg-double\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\tbreak;\n\tcase 0xa0: // and-long\n\tcase 0xc0: // and-long\n\tcase 0xdd: // and-long\n\tcase 0xd5: // and-long\n\tcase 0x95:\n\tcase 0xb5: // and-int\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\tbreak;\n\tcase 0xd6: // orint/lit16\n\tcase 0xc1: // or-long/2addr\n\tcase 0xa1: // or-long\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\tbreak;\n\tcase 0xe0: //lshl\n\tcase 0xc3: //lshl\n\tcase 0xa3: // shl-long\n\tcase 0x98: // shl-long\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tbreak;\n\t}\n\treturn sz;\n}', 'func_before': 'static int dalvik_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tint sz = dalvik_opcodes[data[0]].len;\n\tif (!op) {\n\t\treturn sz;\n\t}\n\tmemset (op, \'\\0\', sizeof (RAnalOp));\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->fail = UT64_MAX;\n\top->refptr = 0;\n\top->size = sz;\n\top->nopcode = 1; // Necessary??\n\top->id = data[0];\n\n\tswitch (data[0]) {\n\tcase 0xca: // rem-float:\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x1b: // const-string/jumbo\n\tcase 0x14: // const\n\tcase 0x15: // const\n\tcase 0x16: // const\n\tcase 0x17: // const\n\tcase 0x42: // const\n\tcase 0x12: // const/4\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vB = (data[1] & 0x0f);\n\t\t\tut32 vA = (data[1] & 0xf0) >> 4;\n\t\t\t// op->stackop = R_ANAL_STACK_SET;\n\t\t\top->ptr = -vA; // why\n\t\t\top->val = vA;\n\t\t\tesilprintf (op, "0x%"PFMT64x",v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x01: // move\n\tcase 0x07: // move-object\t\t\n\tcase 0x04: // mov-wide\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vB = (data[1] & 0x0f);\n\t\t\tut32 vA = (data[1] & 0xf0) >> 4;\n\t\t\top->stackop = R_ANAL_STACK_SET;\n\t\t\top->ptr = -vA;\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x02: // move/from16\n\tcase 0x03: // move/16\n\tcase 0x05: // move-wide/from16\n\tcase 0x06: // mov-wide&17\n\tcase 0x08: // move-object/from16\n\tcase 0x09: // move-object/16\n\tcase 0x13: // const/16\n\tcase 0x18: // const-wide\n\tcase 0x19: // const-wide\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tint vA = (int) data[1];\n\t\t\tut32 vB = (data[3] << 8) | data[2];\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t\top->val = vB;\n\t\t}\n\t\tbreak;\n\tcase 0x0a: // move-result\n\tcase 0x0d: // move-exception\n\tcase 0x0c: // move-result-object\n\tcase 0x0b: // move-result-wide\n\t \t// TODO: add MOVRET OP TYPE ??\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vA = data[1];\n\t\t\tesilprintf (op, "sp,v%d,=[8],8,sp,+=,8", vA);\n\t\t}\n\t\tbreak;\n\tcase 0x1a: // const-string\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vA = data[1];\n\t\t\tut32 vB = (data[3]<<8) | data[2];\n\t\t\tut64 offset = R_ANAL_GET_OFFSET (anal, \'s\', vB);\n\t\t\top->ptr = offset;\n\t\t\tesilprintf (op, "0x%"PFMT64x",v%d,=", offset, vA);\n\t\t}\n\t\tbreak;\n\tcase 0x1c: // const-class\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tbreak;\n\tcase 0x85: // long-to-float\n\tcase 0x8e: // double-to-int\n\tcase 0x89: // float-to-double\n\tcase 0x8a: // double-to-int\n\tcase 0x87: // double-to-int\n\tcase 0x8c: // double-to-float\n\tcase 0x8b: // double-to-long\n\tcase 0x88: // float-to-long\n\tcase 0x86: // long-to-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x81: // int-to-long\n\tcase 0x82: // \n\tcase 0x83: // \n\tcase 0x84: // \n\tcase 0x8d: // int-to-byte\n\tcase 0x8f: // int-to-short\n\tcase 0x20: // instance-of\n\t\top->type = R_ANAL_OP_TYPE_CAST;\n\t\tbreak;\n\tcase 0x21: // array-length\n\t\top->type = R_ANAL_OP_TYPE_LENGTH;\n\t\tbreak;\n\tcase 0x44: // aget\n\tcase 0x45: //aget-bool\n\tcase 0x46:\n\tcase 0x47: //aget-bool\n\tcase 0x48: //aget-byte\n\tcase 0x49: //aget-char\n\tcase 0x4a: //aget-short\n\tcase 0x52: //iget\n\tcase 0x58: //iget-short\n\tcase 0x53: //iget-wide\n\tcase 0x56: //iget-byte\n\tcase 0x57: //iget-char\n\tcase 0xea: //sget-wide-volatile\n\tcase 0x63: //sget-boolean\n\tcase 0xf4: //iget-byte\n\tcase 0x66: //sget-short\n\tcase 0xfd: //sget-object\n\tcase 0x55: //iget-bool\n\tcase 0x60: // sget\n\tcase 0x61: // \n\tcase 0x62: //\n\tcase 0x64: // sget-byte\n\tcase 0x65: // sget-char\n\tcase 0xe3: //iget-volatile\n\tcase 0xe4: //\n\tcase 0xe5: // sget\n\tcase 0xe6: // sget\n\tcase 0x54: // iget-object\n\tcase 0xe7: // iget-object-volatile\n\tcase 0xe8: //iget-bool\n\tcase 0xf3: //iget-bool\n\tcase 0xf8: //iget-bool\n\tcase 0xf2: //iget-quick\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\tbreak;\n\tcase 0x6b: //sput-byte\n\tcase 0x6d: //sput-short\n\tcase 0xeb: //sput-wide-volatile\n\tcase 0x4b: //aput\n\tcase 0x4c: //aput-wide\n\tcase 0x4d: // aput-object\n\tcase 0x4e: // aput-bool\n\tcase 0x4f: // \n\tcase 0x5e: //iput-char\n\tcase 0xfc: //iput-object-volatile\n\tcase 0xf5: //iput-quick\n\tcase 0x5c: //iput-bool\n\tcase 0x69: //sput-object\n\tcase 0x5f: //iput-wide\n\tcase 0xe9: //iput-wide-volatile\n\tcase 0xf6: //iput-wide\n\tcase 0xf7: //iput-wide\n\tcase 0x67: //iput-wide\n\tcase 0x59: //iput-wide\n\tcase 0x5a: //iput-wide\n\tcase 0x5b: //iput-wide\n\tcase 0x5d: //iput-wide\n\tcase 0x50: //\n\tcase 0x51: // aput-short\n\tcase 0x68: // sput-wide\n\tcase 0x6a: // sput-boolean\n\tcase 0x6c: // sput-wide\n\tcase 0xfe: // sput\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t{\n\t\t\tut32 vA = (data[1] & 0x0f);\n\t\t\tut32 vB = (data[1] & 0xf0) >> 4;\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x9d:\n\tcase 0xad: // mul-double\n\tcase 0xc8: // mul-float\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* fall through */\n\tcase 0xcd:\n\tcase 0xd2:\n\tcase 0x92:\n\tcase 0xb2:\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\tbreak;\n\tcase 0x7c: // not-int\n\tcase 0x7e: // not-long\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\tbreak;\n\tcase 0xa4: // shr-long\n\tcase 0xba: // ushr-int/2addr\n\tcase 0xe2: // ushr-int\n\tcase 0xa5: // ushr-long\n\tcase 0x9a: // ushr-long\n\tcase 0xc5: // ushr-long/2addr\n\tcase 0xc4: // shr-long/2addr\n\tcase 0xe1: // shr-int/lit8\n\tcase 0x99: // shr-int\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tbreak;\n\tcase 0xaa: // rem-float\n\tcase 0xcf: // rem-double\n\tcase 0xaf: // rem-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0xb4: // rem-int/2addr\n\tcase 0xdc: // rem-int/lit8\n\tcase 0xd4: // rem-int\n\tcase 0xbf: // rem-long/2addr\n\tcase 0x9f: // rem-long\n\tcase 0x94: // rem-int\n\t\top->type = R_ANAL_OP_TYPE_MOD; // mod = rem\n\t\tbreak;\n\tcase 0xd7:\n\tcase 0xd9:\n\tcase 0xda:\n\tcase 0xde:\n\tcase 0xdf:\n\tcase 0x96:\n\tcase 0xc2: // xor-long\n\tcase 0x97: // xor-int\n\tcase 0xa2: // xor-long\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\tbreak;\n\tcase 0xc9: // div-float\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x93: // div-int\n\tcase 0xd3: // div-int/lit16\n\tcase 0xdb: // div-int/lit8\n\tcase 0xce: // div-double\n\tcase 0x9e: // div-double\n\tcase 0xbe: // div-double\n\tcase 0xae: // div-double\n\tcase 0xa9: // div-float\n\tcase 0xb3: // div-int/2addr\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\tbreak;\n\tcase 0x0e: // return-void\n\tcase 0x0f: // return\n\tcase 0x10: // return-wide\n\tcase 0x11: // return-object\n\tcase 0xf1: // return-void-barrier\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->eob = true;\n\t\t//TODO: handle return if(0x0e) {}\xa0else {}\n\t\tif (data[0] == 0x0e) {// return-void\n\t\t\tesilprintf (op, "sp,[8],ip,=,8,sp,+=");\n\t\t} else {\n\t\t\tut32 vA = data[1];\n\t\t\tesilprintf (op, "sp,[8],ip,=,8,sp,+=,8,sp,-=,v%d,sp,=[8]", vA);\n\t\t}\n\t\tbreak;\n\tcase 0x28: // goto\n\t\top->jump = addr + ((char)data[1])*2;\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\top->eob = true;\n\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\tbreak;\n\tcase 0x29: // goto/16\n\t\top->jump = addr + (short)(data[2]|data[3]<<8)*2;\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\top->eob = true;\n\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\tbreak;\n\tcase 0x2a: // goto/32\n\t\top->jump = addr + (int)(data[2]|(data[3]<<8)|(data[4]<<16)|(data[5]<<24))*2;\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\top->eob = true;\n\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\tbreak;\n\tcase 0x2c:\n\tcase 0x2b:\n\t\top->type = R_ANAL_OP_TYPE_SWITCH;\n\t\tbreak;\n\tcase 0x2d: // cmpl-float\n\tcase 0x2e: // cmpg-float\n\tcase 0x3f: // cmpg-float // ???? wrong disasm imho 2e0f12003f0f\n\tcase 0x2f: // cmpl-double\n\tcase 0x30: // cmlg-double\n\tcase 0x31: // cmp-long\n\tcase 0x1f: // check-cast\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\tbreak;\n\tcase 0x32: // if-eq\n\tcase 0x33: // if-ne\n\tcase 0x34: // if-lt\n\tcase 0x35: // if-ge\n\tcase 0x36: // if-gt\n\tcase 0x37: // if-le\n\tcase 0x38: // if-eqz\n\tcase 0x39: // if-nez\n\tcase 0x3a: // if-ltz\n\tcase 0x3b: // if-gez\n\tcase 0x3c: // if-gtz\n\tcase 0x3d: // if-lez\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t//XXX fix this better the check is to avoid an oob\n\t\top->jump = addr + (len>3?(short)(data[2]|data[3]<<8)*2 : 0);\n\t\top->fail = addr + sz;\n\t\top->eob = true;\n\t\tbreak;\n\tcase 0xec: // breakpoint\n\tcase 0x1d: // monitor-enter\n\t\top->type = R_ANAL_OP_TYPE_UPUSH;\n\t\tbreak;\n\tcase 0x1e: // monitor-exit /// wrong type?\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\tbreak;\n\tcase 0x6f: // invoke-super\n\tcase 0xfa: // invoke-super-quick\n\tcase 0x70: // invoke-direct\n\tcase 0x71: // invoke-static\n\tcase 0x72: // invoke-interface\n\tcase 0x73: //\n\tcase 0x74: //\n\tcase 0x75: //\n\tcase 0x76: // invoke-direct\n\tcase 0x77: //\n\tcase 0x78: // invokeinterface/range\n\tcase 0xb9: // invokeinterface\n\tcase 0xb7: // invokespecial\n\tcase 0xb8: // invokestatic\n\tcase 0xb6: // invokevirtual\n\tcase 0x6e: // invoke-virtual\n\tcase 0xf0: // invoke-object-init-range\n\tcase 0xf9: // invoke-virtual-quick/range\n\tcase 0xfb: // invoke-super-quick/range\n\t\t{\n\t\t//XXX fix this better since the check avoid an oob\n\t\t//but the jump will be incorrect\n\t\tut32 vB = len > 3?(data[3] << 8) | data[2] : 0;\n\t\top->jump = anal->binb.get_offset (anal->binb.bin, \'m\', vB);\n\t\top->fail = addr + sz;\n\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\t// TODO: handle /range instructions\n\t\tesilprintf (op, "8,sp,-=,0x%"PFMT64x",sp,=[8],0x%"PFMT64x",ip,=", addr);\n\n\t\t}\n\t\tbreak;\n\tcase 0x27: // throw\n\tcase 0xee: // execute-inline\n\tcase 0xef: // execute-inline/range\n\tcase 0xed: // throw-verification-error\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\tbreak;\n#if 0\n\tcase 0xbb: // new\n\tcase 0xbc: // newarray\n\tcase 0xc5: // multi new array\n#endif\n\tcase 0x22: // new-instance\n\tcase 0x23: // new-array\n\tcase 0x24: // filled-new-array\n\tcase 0x25: // filled-new-array-range\n\tcase 0x26: // filled-new-array-data\n\t\top->type = R_ANAL_OP_TYPE_NEW;\n\t\t// 0x1c, 0x1f, 0x22\n\t\t{\n\t\t\t//int vA = (int) data[1];\n\t\t\tint vB = (data[3] << 8) | data[2];\n\t\t\t// resolve class name for vB\n\t\t\tut64 off = R_ANAL_GET_OFFSET (anal, \'t\', vB);\n\t\t\top->ptr = off;\n\t\t}\n\t\tbreak;\n\tcase 0x00: // nop\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\tbreak;\n\tcase 0x90: // add-int\n\tcase 0x9b: // add-long\n\tcase 0xa6: // add-float\n\tcase 0xac: // add-double\n\tcase 0xb0: // add-int/2addr\n\tcase 0xbb: // add-long/2addr\n\tcase 0xc6: // add-float/2addr\n\tcase 0xcb: // add-double/2addr\n\tcase 0xd0: // add-int/lit16\n\tcase 0xd8: // add-int/lit8\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tbreak;\n\tcase 0xa7: // sub-float\n\tcase 0xcc: //sub-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* fall thru */\n\tcase 0xc7:\n\tcase 0xbc:\n\tcase 0x91:\n\tcase 0xb1: //sub-int/2addr\n\tcase 0xd1: //sub-int/2addr\n\tcase 0x9c: //sub-long\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\tbreak;\n\tcase 0x7b: // neg-int\n\tcase 0x7d: // neg-long\n\tcase 0x7f: // neg-float\n\tcase 0x80: // neg-double\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\tbreak;\n\tcase 0xa0: // and-long\n\tcase 0xc0: // and-long\n\tcase 0xdd: // and-long\n\tcase 0xd5: // and-long\n\tcase 0x95:\n\tcase 0xb5: // and-int\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\tbreak;\n\tcase 0xd6: // orint/lit16\n\tcase 0xc1: // or-long/2addr\n\tcase 0xa1: // or-long\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\tbreak;\n\tcase 0xe0: //lshl\n\tcase 0xc3: //lshl\n\tcase 0xa3: // shl-long\n\tcase 0x98: // shl-long\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tbreak;\n\t}\n\treturn sz;\n}', 'diff_func': '--- func_before\n+++ func_after\n@@ -57,7 +57,7 @@\n \tcase 0x18: // const-wide\n \tcase 0x19: // const-wide\n \t\top->type = R_ANAL_OP_TYPE_MOV;\n-\t\t{\n+\t\tif (len > 2) {\n \t\t\tint vA = (int) data[1];\n \t\t\tut32 vB = (data[3] << 8) | data[2];\n \t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n@@ -77,7 +77,7 @@\n \t\tbreak;\n \tcase 0x1a: // const-string\n \t\top->type = R_ANAL_OP_TYPE_MOV;\n-\t\t{\n+\t\tif (len > 2) {\n \t\t\tut32 vA = data[1];\n \t\t\tut32 vB = (data[3]<<8) | data[2];\n \t\t\tut64 offset = R_ANAL_GET_OFFSET (anal, \'s\', vB);\n@@ -267,16 +267,20 @@\n \t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n \t\tbreak;\n \tcase 0x29: // goto/16\n-\t\top->jump = addr + (short)(data[2]|data[3]<<8)*2;\n-\t\top->type = R_ANAL_OP_TYPE_JMP;\n-\t\top->eob = true;\n-\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n+\t\tif (len > 2) {\n+\t\t\top->jump = addr + (short)(data[2]|data[3]<<8)*2;\n+\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n+\t\t\top->eob = true;\n+\t\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n+\t\t}\n \t\tbreak;\n \tcase 0x2a: // goto/32\n-\t\top->jump = addr + (int)(data[2]|(data[3]<<8)|(data[4]<<16)|(data[5]<<24))*2;\n-\t\top->type = R_ANAL_OP_TYPE_JMP;\n-\t\top->eob = true;\n-\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n+\t\tif (len > 2) {\n+\t\t\top->jump = addr + (int)(data[2]|(data[3]<<8)|(data[4]<<16)|(data[5]<<24))*2;\n+\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n+\t\t\top->eob = true;\n+\t\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n+\t\t}\n \t\tbreak;\n \tcase 0x2c:\n \tcase 0x2b:\n@@ -305,9 +309,11 @@\n \tcase 0x3d: // if-lez\n \t\top->type = R_ANAL_OP_TYPE_CJMP;\n \t\t//XXX fix this better the check is to avoid an oob\n-\t\top->jump = addr + (len>3?(short)(data[2]|data[3]<<8)*2 : 0);\n-\t\top->fail = addr + sz;\n-\t\top->eob = true;\n+\t\tif (len > 2) {\n+\t\t\top->jump = addr + (len>3?(short)(data[2]|data[3]<<8)*2 : 0);\n+\t\t\top->fail = addr + sz;\n+\t\t\top->eob = true;\n+\t\t}\n \t\tbreak;\n \tcase 0xec: // breakpoint\n \tcase 0x1d: // monitor-enter\n@@ -335,16 +341,15 @@\n \tcase 0xf0: // invoke-object-init-range\n \tcase 0xf9: // invoke-virtual-quick/range\n \tcase 0xfb: // invoke-super-quick/range\n-\t\t{\n-\t\t//XXX fix this better since the check avoid an oob\n-\t\t//but the jump will be incorrect\n-\t\tut32 vB = len > 3?(data[3] << 8) | data[2] : 0;\n-\t\top->jump = anal->binb.get_offset (anal->binb.bin, \'m\', vB);\n-\t\top->fail = addr + sz;\n-\t\top->type = R_ANAL_OP_TYPE_CALL;\n-\t\t// TODO: handle /range instructions\n-\t\tesilprintf (op, "8,sp,-=,0x%"PFMT64x",sp,=[8],0x%"PFMT64x",ip,=", addr);\n-\n+\t\tif (len > 2) {\n+\t\t\t//XXX fix this better since the check avoid an oob\n+\t\t\t//but the jump will be incorrect\n+\t\t\tut32 vB = len > 3?(data[3] << 8) | data[2] : 0;\n+\t\t\top->jump = anal->binb.get_offset (anal->binb.bin, \'m\', vB);\n+\t\t\top->fail = addr + sz;\n+\t\t\top->type = R_ANAL_OP_TYPE_CALL;\n+\t\t\t// TODO: handle /range instructions\n+\t\t\tesilprintf (op, "8,sp,-=,0x%"PFMT64x",sp,=[8],0x%"PFMT64x",ip,=", addr);\n \t\t}\n \t\tbreak;\n \tcase 0x27: // throw\n@@ -365,7 +370,7 @@\n \tcase 0x26: // filled-new-array-data\n \t\top->type = R_ANAL_OP_TYPE_NEW;\n \t\t// 0x1c, 0x1f, 0x22\n-\t\t{\n+\t\tif (len > 2) {\n \t\t\t//int vA = (int) data[1];\n \t\t\tint vB = (data[3] << 8) | data[2];\n \t\t\t// resolve class name for vB', 'diff_line_info': {'deleted_lines': ['\t\t{', '\t\t{', '\t\top->jump = addr + (short)(data[2]|data[3]<<8)*2;', '\t\top->type = R_ANAL_OP_TYPE_JMP;', '\t\top->eob = true;', '\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);', '\t\top->jump = addr + (int)(data[2]|(data[3]<<8)|(data[4]<<16)|(data[5]<<24))*2;', '\t\top->type = R_ANAL_OP_TYPE_JMP;', '\t\top->eob = true;', '\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);', '\t\top->jump = addr + (len>3?(short)(data[2]|data[3]<<8)*2 : 0);', '\t\top->fail = addr + sz;', '\t\top->eob = true;', '\t\t{', '\t\t//XXX fix this better since the check avoid an oob', '\t\t//but the jump will be incorrect', '\t\tut32 vB = len > 3?(data[3] << 8) | data[2] : 0;', "\t\top->jump = anal->binb.get_offset (anal->binb.bin, 'm', vB);", '\t\top->fail = addr + sz;', '\t\top->type = R_ANAL_OP_TYPE_CALL;', '\t\t// TODO: handle /range instructions', '\t\tesilprintf (op, "8,sp,-=,0x%"PFMT64x",sp,=[8],0x%"PFMT64x",ip,=", addr);', '', '\t\t{'], 'added_lines': ['\t\tif (len > 2) {', '\t\tif (len > 2) {', '\t\tif (len > 2) {', '\t\t\top->jump = addr + (short)(data[2]|data[3]<<8)*2;', '\t\t\top->type = R_ANAL_OP_TYPE_JMP;', '\t\t\top->eob = true;', '\t\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);', '\t\t}', '\t\tif (len > 2) {', '\t\t\top->jump = addr + (int)(data[2]|(data[3]<<8)|(data[4]<<16)|(data[5]<<24))*2;', '\t\t\top->type = R_ANAL_OP_TYPE_JMP;', '\t\t\top->eob = true;', '\t\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);', '\t\t}', '\t\tif (len > 2) {', '\t\t\top->jump = addr + (len>3?(short)(data[2]|data[3]<<8)*2 : 0);', '\t\t\top->fail = addr + sz;', '\t\t\top->eob = true;', '\t\t}', '\t\tif (len > 2) {', '\t\t\t//XXX fix this better since the check avoid an oob', '\t\t\t//but the jump will be incorrect', '\t\t\tut32 vB = len > 3?(data[3] << 8) | data[2] : 0;', "\t\t\top->jump = anal->binb.get_offset (anal->binb.bin, 'm', vB);", '\t\t\top->fail = addr + sz;', '\t\t\top->type = R_ANAL_OP_TYPE_CALL;', '\t\t\t// TODO: handle /range instructions', '\t\t\tesilprintf (op, "8,sp,-=,0x%"PFMT64x",sp,=[8],0x%"PFMT64x",ip,=", addr);', '\t\tif (len > 2) {']}, 'is_vul': True, 'commit_hash': '24282de142000d2ed2c19783b40a1351872dfc54', 'parent_commit_hash': '9074d2904a43563df5207de40d7edbe6ea82262b', 'func_graph_path_before': 'radareorg/radare2/24282de142000d2ed2c19783b40a1351872dfc54/anal_dalvik.c/vul/before/0.json', 'delete_slice': ['', '\t\t\top->ptr = -vA; // why', "\tmemset (op, '\\0', sizeof (RAnalOp));", '\tcase 0x04: // mov-wide', '\t\top->type = R_ANAL_OP_TYPE_MUL;', '\t\top->type = R_ANAL_OP_TYPE_CJMP;', '\t\top->type = R_ANAL_OP_TYPE_MOD; // mod = rem', '\t\top->jump = addr + ((char)data[1])*2;', '\t\top->type = R_ANAL_OP_TYPE_NOT;', '\tswitch (data[0]) {', '\t\top->jump = addr + (int)(data[2]|(data[3]<<8)|(data[4]<<16)|(data[5]<<24))*2;', '\t\tif (data[0] == 0x0e) {// return-void', '\tcase 0x28: // goto', '\tcase 0x1a: // const-string', '\top->ptr = UT64_MAX;', '\t\top->eob = true;', '\t\t\tut32 vA = data[1];', '\t\top->type = R_ANAL_OP_TYPE_XOR;', '\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);', '\t\top->jump = addr + (len>3?(short)(data[2]|data[3]<<8)*2 : 0);', '\tcase 0xf1: // return-void-barrier', '\t\top->type = R_ANAL_OP_TYPE_CAST;', '\t\t// TODO: handle /range instructions', '\top->nopcode = 1; // Necessary??', '\t\t\tut32 vB = (data[1] & 0xf0) >> 4;', '\tcase 0xf9: // invoke-virtual-quick/range', '\tint sz = dalvik_opcodes[data[0]].len;', '\t\t\tint vA = (int) data[1];', '\t\t\tesilprintf (op, "sp,[8],ip,=,8,sp,+=");', '\tcase 0x19: // const-wide', '\tcase 0xfb: // invoke-super-quick/range', '\t\t{', '\top->val = UT64_MAX;', '\t\top->type = R_ANAL_OP_TYPE_CMP;', '\top->fail = UT64_MAX;', '\t\t\top->ptr = offset;', '\tif (!op) {', 'static int dalvik_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {', '\t\t\tesilprintf (op, "sp,v%d,=[8],8,sp,+=,8", vA);', '\t\top->type = R_ANAL_OP_TYPE_NOP;', '\tcase 0x0b: // move-result-wide', '\t\tbreak;', '\t\top->type = R_ANAL_OP_TYPE_RET;', '\t\top->type = R_ANAL_OP_TYPE_SHR;', '\tcase 0xfe: // sput', '\t\top->family = R_ANAL_OP_FAMILY_FPU;', '\t\t\top->stackop = R_ANAL_STACK_SET;', '\t\t\tint vB = (data[3] << 8) | data[2];', '\t\top->type = R_ANAL_OP_TYPE_SWITCH;', '\t\top->type = R_ANAL_OP_TYPE_JMP;', '\t\t\top->ptr = -vA;', '\tcase 0x29: // goto/16', '\t\t\tut32 vA = (data[1] & 0xf0) >> 4;', '\t\t//XXX fix this better since the check avoid an oob', '\t\t\top->val = vB;', '\t\top->type = R_ANAL_OP_TYPE_LOAD;', '\treturn sz;', '\t\t\tut32 vB = (data[3]<<8) | data[2];', '\t\t\tut32 vA = (data[1] & 0x0f);', '\tcase 0x2a: // goto/32', '\t\top->type = R_ANAL_OP_TYPE_POP;', '\top->size = sz;', '\t\tut32 vB = len > 3?(data[3] << 8) | data[2] : 0;', '\t\top->type = R_ANAL_OP_TYPE_SHL;', '\t\top->type = R_ANAL_OP_TYPE_LENGTH;', '\t\top->type = R_ANAL_OP_TYPE_SUB;', '\t\top->type = R_ANAL_OP_TYPE_CALL;', '\t\t//but the jump will be incorrect', '\t\t\tesilprintf (op, "sp,[8],ip,=,8,sp,+=,8,sp,-=,v%d,sp,=[8]", vA);', '\t\top->type = R_ANAL_OP_TYPE_NEW;', '\top->id = data[0];', '\t\t\tut32 vB = (data[3] << 8) | data[2];', '\t\top->type = R_ANAL_OP_TYPE_UPUSH;', '\t\top->type = R_ANAL_OP_TYPE_ADD;', '\t\top->jump = addr + (short)(data[2]|data[3]<<8)*2;', "\t\top->jump = anal->binb.get_offset (anal->binb.bin, 'm', vB);", '\top->type = R_ANAL_OP_TYPE_UNK;', '\top->refptr = 0;', '\top->jump = UT64_MAX;', '\t\top->type = R_ANAL_OP_TYPE_DIV;', '\t\top->type = R_ANAL_OP_TYPE_STORE;', '\t\t\top->ptr = off;', '\t\top->type = R_ANAL_OP_TYPE_SWI;', '\t\t\tut32 vB = (data[1] & 0x0f);', '\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);', '\t\top->type = R_ANAL_OP_TYPE_OR;', '\t\t\top->val = vA;', '\tcase 0x12: // const/4', '\t\top->fail = addr + sz;', '\t\top->type = R_ANAL_OP_TYPE_MOV;', '\t\tesilprintf (op, "8,sp,-=,0x%"PFMT64x",sp,=[8],0x%"PFMT64x",ip,=", addr);', '\t\top->type = R_ANAL_OP_TYPE_AND;'], 'pre_function_simplication': 'static int dalvik_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tint sz = dalvik_opcodes[data[0]].len;\n\tif (!op) {\n\t\treturn sz;\n\t}\n\tmemset (op, \'\\0\', sizeof (RAnalOp));\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->fail = UT64_MAX;\n\top->refptr = 0;\n\top->size = sz;\n\top->nopcode = 1;\n\top->id = data[0];\n\tswitch (data[0]) {\n\tcase 0xca: // rem-float:\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x1b: // const-string/jumbo\n\tcase 0x14: // const\n\tcase 0x15: // const\n\tcase 0x16: // const\n\tcase 0x17: // const\n\tcase 0x42: // const\n\tcase 0x12: // const/4\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vB = (data[1] & 0x0f);\n\t\t\tut32 vA = (data[1] & 0xf0) >> 4;\n\t\t\t// op->stackop = R_ANAL_STACK_SET;\n\t\t\top->ptr = -vA; // why\n\t\t\top->val = vA;\n\t\t\tesilprintf (op, "0x%"PFMT64x",v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x01: // move\n\tcase 0x07: // move-object\t\t\n\tcase 0x04: // mov-wide\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vB = (data[1] & 0x0f);\n\t\t\tut32 vA = (data[1] & 0xf0) >> 4;\n\t\t\top->stackop = R_ANAL_STACK_SET;\n\t\t\top->ptr = -vA;\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x02: // move/from16\n\tcase 0x03: // move/16\n\tcase 0x05: // move-wide/from16\n\tcase 0x06: // mov-wide&17\n\tcase 0x08: // move-object/from16\n\tcase 0x09: // move-object/16\n\tcase 0x13: // const/16\n\tcase 0x18: // const-wide\n\tcase 0x19: // const-wide\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tint vA = (int) data[1];\n\t\t\tut32 vB = (data[3] << 8) | data[2];\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t\top->val = vB;\n\t\t}\n\t\tbreak;\n\tcase 0x0a: // move-result\n\tcase 0x0d: // move-exception\n\tcase 0x0c: // move-result-object\n\tcase 0x0b: // move-result-wide\n\t \t// TODO: add MOVRET OP TYPE ??\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vA = data[1];\n\t\t\tesilprintf (op, "sp,v%d,=[8],8,sp,+=,8", vA);\n\t\t}\n\t\tbreak;\n\tcase 0x1a: // const-string\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vA = data[1];\n\t\t\tut32 vB = (data[3]<<8) | data[2];\n\t\t\tut64 offset = R_ANAL_GET_OFFSET (anal, \'s\', vB);\n\t\t\top->ptr = offset;\n\t\t\tesilprintf (op, "0x%"PFMT64x",v%d,=", offset, vA);\n\t\t}\n\t\tbreak;\n\tcase 0x1c: // const-class\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tbreak;\n\tcase 0x85: // long-to-float\n\tcase 0x8e: // double-to-int\n\tcase 0x89: // float-to-double\n\tcase 0x8a: // double-to-int\n\tcase 0x87: // double-to-int\n\tcase 0x8c: // double-to-float\n\tcase 0x8b: // double-to-long\n\tcase 0x88: // float-to-long\n\tcase 0x86: // long-to-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x81: // int-to-long\n\tcase 0x82: // \n\tcase 0x83: // \n\tcase 0x84: // \n\tcase 0x8d: // int-to-byte\n\tcase 0x8f: // int-to-short\n\tcase 0x20: // instance-of\n\t\top->type = R_ANAL_OP_TYPE_CAST;\n\t\tbreak;\n\tcase 0x21: // array-length\n\t\top->type = R_ANAL_OP_TYPE_LENGTH;\n\t\tbreak;\n\tcase 0x44: // aget\n\tcase 0x45: //aget-bool\n\tcase 0x46:\n\tcase 0x47: //aget-bool\n\tcase 0x48: //aget-byte\n\tcase 0x49: //aget-char\n\tcase 0x4a: //aget-short\n\tcase 0x52: //iget\n\tcase 0x58: //iget-short\n\tcase 0x53: //iget-wide\n\tcase 0x56: //iget-byte\n\tcase 0x57: //iget-char\n\tcase 0xea: //sget-wide-volatile\n\tcase 0x63: //sget-boolean\n\tcase 0xf4: //iget-byte\n\tcase 0x66: //sget-short\n\tcase 0xfd: //sget-object\n\tcase 0x55: //iget-bool\n\tcase 0x60: // sget\n\tcase 0x61: // \n\tcase 0x62: //\n\tcase 0x64: // sget-byte\n\tcase 0x65: // sget-char\n\tcase 0xe3: //iget-volatile\n\tcase 0xe4: //\n\tcase 0xe5: // sget\n\tcase 0xe6: // sget\n\tcase 0x54: // iget-object\n\tcase 0xe7: // iget-object-volatile\n\tcase 0xe8: //iget-bool\n\tcase 0xf3: //iget-bool\n\tcase 0xf8: //iget-bool\n\tcase 0xf2: //iget-quick\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\tbreak;\n\tcase 0x6b: //sput-byte\n\tcase 0x6d: //sput-short\n\tcase 0xeb: //sput-wide-volatile\n\tcase 0x4b: //aput\n\tcase 0x4c: //aput-wide\n\tcase 0x4d: // aput-object\n\tcase 0x4e: // aput-bool\n\tcase 0x4f: // \n\tcase 0x5e: //iput-char\n\tcase 0xfc: //iput-object-volatile\n\tcase 0xf5: //iput-quick\n\tcase 0x5c: //iput-bool\n\tcase 0x69: //sput-object\n\tcase 0x5f: //iput-wide\n\tcase 0xe9: //iput-wide-volatile\n\tcase 0xf6: //iput-wide\n\tcase 0xf7: //iput-wide\n\tcase 0x67: //iput-wide\n\tcase 0x59: //iput-wide\n\tcase 0x5a: //iput-wide\n\tcase 0x5b: //iput-wide\n\tcase 0x5d: //iput-wide\n\tcase 0x50: //\n\tcase 0x51: // aput-short\n\tcase 0x68: // sput-wide\n\tcase 0x6a: // sput-boolean\n\tcase 0x6c: // sput-wide\n\tcase 0xfe: // sput\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t{\n\t\t\tut32 vA = (data[1] & 0x0f);\n\t\t\tut32 vB = (data[1] & 0xf0) >> 4;\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x9d:\n\tcase 0xad: // mul-double\n\tcase 0xc8: // mul-float\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* fall through */\n\tcase 0xcd:\n\tcase 0xd2:\n\tcase 0x92:\n\tcase 0xb2:\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\tbreak;\n\tcase 0x7c: // not-int\n\tcase 0x7e: // not-long\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\tbreak;\n\tcase 0xa4: // shr-long\n\tcase 0xba: // ushr-int/2addr\n\tcase 0xe2: // ushr-int\n\tcase 0xa5: // ushr-long\n\tcase 0x9a: // ushr-long\n\tcase 0xc5: // ushr-long/2addr\n\tcase 0xc4: // shr-long/2addr\n\tcase 0xe1: // shr-int/lit8\n\tcase 0x99: // shr-int\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tbreak;\n\tcase 0xaa: // rem-float\n\tcase 0xcf: // rem-double\n\tcase 0xaf: // rem-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0xb4: // rem-int/2addr\n\tcase 0xdc: // rem-int/lit8\n\tcase 0xd4: // rem-int\n\tcase 0xbf: // rem-long/2addr\n\tcase 0x9f: // rem-long\n\tcase 0x94: // rem-int\n\t\top->type = R_ANAL_OP_TYPE_MOD; // mod = rem\n\t\tbreak;\n\tcase 0xd7:\n\tcase 0xd9:\n\tcase 0xda:\n\tcase 0xde:\n\tcase 0xdf:\n\tcase 0x96:\n\tcase 0xc2: // xor-long\n\tcase 0x97: // xor-int\n\tcase 0xa2: // xor-long\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\tbreak;\n\tcase 0xc9: // div-float\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x93: // div-int\n\tcase 0xd3: // div-int/lit16\n\tcase 0xdb: // div-int/lit8\n\tcase 0xce: // div-double\n\tcase 0x9e: // div-double\n\tcase 0xbe: // div-double\n\tcase 0xae: // div-double\n\tcase 0xa9: // div-float\n\tcase 0xb3: // div-int/2addr\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\tbreak;\n\tcase 0x0e: // return-void\n\tcase 0x0f: // return\n\tcase 0x10: // return-wide\n\tcase 0x11: // return-object\n\tcase 0xf1: // return-void-barrier\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->eob = true;\n\t\t//TODO: handle return if(0x0e) {}\xa0else {}\n\t\tif (data[0] == 0x0e) {// return-void\n\t\t\tesilprintf (op, "sp,[8],ip,=,8,sp,+=");\n\t\t} else {\n\t\t\tut32 vA = data[1];\n\t\t\tesilprintf (op, "sp,[8],ip,=,8,sp,+=,8,sp,-=,v%d,sp,=[8]", vA);\n\t\t}\n\t\tbreak;\n\tcase 0x28: // goto\n\t\top->jump = addr + ((char)data[1])*2;\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\top->eob = true;\n\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\tbreak;\n\tcase 0x29: // goto/16\n\t\top->jump = addr + (short)(data[2]|data[3]<<8)*2;\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\top->eob = true;\n\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\tbreak;\n\tcase 0x2a: // goto/32\n\t\top->jump = addr + (int)(data[2]|(data[3]<<8)|(data[4]<<16)|(data[5]<<24))*2;\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\top->eob = true;\n\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\tbreak;\n\tcase 0x2c:\n\tcase 0x2b:\n\t\top->type = R_ANAL_OP_TYPE_SWITCH;\n\t\tbreak;\n\tcase 0x2d: // cmpl-float\n\tcase 0x2e: // cmpg-float\n\tcase 0x3f: // cmpg-float // ???? wrong disasm imho 2e0f12003f0f\n\tcase 0x2f: // cmpl-double\n\tcase 0x30: // cmlg-double\n\tcase 0x31: // cmp-long\n\tcase 0x1f: // check-cast\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\tbreak;\n\tcase 0x32: // if-eq\n\tcase 0x33: // if-ne\n\tcase 0x34: // if-lt\n\tcase 0x35: // if-ge\n\tcase 0x36: // if-gt\n\tcase 0x37: // if-le\n\tcase 0x38: // if-eqz\n\tcase 0x39: // if-nez\n\tcase 0x3a: // if-ltz\n\tcase 0x3b: // if-gez\n\tcase 0x3c: // if-gtz\n\tcase 0x3d: // if-lez\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t//XXX fix this better the check is to avoid an oob\n\t\top->jump = addr + (len>3?(short)(data[2]|data[3]<<8)*2 : 0);\n\t\top->fail = addr + sz;\n\t\top->eob = true;\n\t\tbreak;\n\tcase 0xec: // breakpoint\n\tcase 0x1d: // monitor-enter\n\t\top->type = R_ANAL_OP_TYPE_UPUSH;\n\t\tbreak;\n\tcase 0x1e: // monitor-exit /// wrong type?\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\tbreak;\n\tcase 0x6f: // invoke-super\n\tcase 0xfa: // invoke-super-quick\n\tcase 0x70: // invoke-direct\n\tcase 0x71: // invoke-static\n\tcase 0x72: // invoke-interface\n\tcase 0x73: //\n\tcase 0x74: //\n\tcase 0x75: //\n\tcase 0x76: // invoke-direct\n\tcase 0x77: //\n\tcase 0x78: // invokeinterface/range\n\tcase 0xb9: // invokeinterface\n\tcase 0xb7: // invokespecial\n\tcase 0xb8: // invokestatic\n\tcase 0xb6: // invokevirtual\n\tcase 0x6e: // invoke-virtual\n\tcase 0xf0: // invoke-object-init-range\n\tcase 0xf9: // invoke-virtual-quick/range\n\tcase 0xfb: // invoke-super-quick/range\n\t\t{\n\t\t//XXX fix this better since the check avoid an oob\n\t\t//but the jump will be incorrect\n\t\tut32 vB = len > 3?(data[3] << 8) | data[2] : 0;\n\t\top->jump = anal->binb.get_offset (anal->binb.bin, \'m\', vB);\n\t\top->fail = addr + sz;\n\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\t// TODO: handle /range instructions\n\t\tesilprintf (op, "8,sp,-=,0x%"PFMT64x",sp,=[8],0x%"PFMT64x",ip,=", addr);\n\n\t\t}\n\t\tbreak;\n\tcase 0x27: // throw\n\tcase 0xee: // execute-inline\n\tcase 0xef: // execute-inline/range\n\tcase 0xed: // throw-verification-error\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\tbreak;\n#if 0\n\tcase 0xbb: // new\n\tcase 0xbc: // newarray\n\tcase 0xc5: // multi new array\n#endif\n\tcase 0x22: // new-instance\n\tcase 0x23: // new-array\n\tcase 0x24: // filled-new-array\n\tcase 0x25: // filled-new-array-range\n\tcase 0x26: // filled-new-array-data\n\t\top->type = R_ANAL_OP_TYPE_NEW;\n\t\t// 0x1c, 0x1f, 0x22\n\t\t{\n\t\t\t//int vA = (int) data[1];\n\t\t\tint vB = (data[3] << 8) | data[2];\n\t\t\t// resolve class name for vB\n\t\t\tut64 off = R_ANAL_GET_OFFSET (anal, \'t\', vB);\n\t\t\top->ptr = off;\n\t\t}\n\t\tbreak;\n\tcase 0x00: // nop\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\tbreak;\n\tcase 0x90: // add-int\n\tcase 0x9b: // add-long\n\tcase 0xa6: // add-float\n\tcase 0xac: // add-double\n\tcase 0xb0: // add-int/2addr\n\tcase 0xbb: // add-long/2addr\n\tcase 0xc6: // add-float/2addr\n\tcase 0xcb: // add-double/2addr\n\tcase 0xd0: // add-int/lit16\n\tcase 0xd8: // add-int/lit8\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tbreak;\n\tcase 0xa7: // sub-float\n\tcase 0xcc: //sub-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* fall thru */\n\tcase 0xc7:\n\tcase 0xbc:\n\tcase 0x91:\n\tcase 0xb1: //sub-int/2addr\n\tcase 0xd1: //sub-int/2addr\n\tcase 0x9c: //sub-long\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\tbreak;\n\tcase 0x7b: // neg-int\n\tcase 0x7d: // neg-long\n\tcase 0x7f: // neg-float\n\tcase 0x80: // neg-double\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\tbreak;\n\tcase 0xa0: // and-long\n\tcase 0xc0: // and-long\n\tcase 0xdd: // and-long\n\tcase 0xd5: // and-long\n\tcase 0x95:\n\tcase 0xb5: // and-int\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\tbreak;\n\tcase 0xd6: // orint/lit16\n\tcase 0xc1: // or-long/2addr\n\tcase 0xa1: // or-long\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\tbreak;\n\tcase 0xe0: //lshl\n\tcase 0xc3: //lshl\n\tcase 0xa3: // shl-long\n\tcase 0x98: // shl-long\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tbreak;\n\t}\n\n\teturn sz;\n\n}', 'post_function_simplication': 'static int dalvik_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tint sz = dalvik_opcodes[data[0]].len;\n\tif (!op) {\n\t\treturn sz;\n\t}\n\tmemset (op, \'\\0\', sizeof (RAnalOp));\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->fail = UT64_MAX;\n\top->refptr = 0;\n\top->size = sz;\n\top->nopcode = 1;\n\top->id = data[0];\n\tswitch (data[0]) {\n\tcase 0xca: // rem-float:\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x1b: // const-string/jumbo\n\tcase 0x14: // const\n\tcase 0x15: // const\n\tcase 0x16: // const\n\tcase 0x17: // const\n\tcase 0x42: // const\n\tcase 0x12: // const/4\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vB = (data[1] & 0x0f);\n\t\t\tut32 vA = (data[1] & 0xf0) >> 4;\n\t\t\t// op->stackop = R_ANAL_STACK_SET;\n\t\t\top->ptr = -vA; // why\n\t\t\top->val = vA;\n\t\t\tesilprintf (op, "0x%"PFMT64x",v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x01: // move\n\tcase 0x07: // move-object\t\t\n\tcase 0x04: // mov-wide\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vB = (data[1] & 0x0f);\n\t\t\tut32 vA = (data[1] & 0xf0) >> 4;\n\t\t\top->stackop = R_ANAL_STACK_SET;\n\t\t\top->ptr = -vA;\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x02: // move/from16\n\tcase 0x03: // move/16\n\tcase 0x05: // move-wide/from16\n\tcase 0x06: // mov-wide&17\n\tcase 0x08: // move-object/from16\n\tcase 0x09: // move-object/16\n\tcase 0x13: // const/16\n\tcase 0x18: // const-wide\n\tcase 0x19: // const-wide\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tif (len > 2) {\n\t\t\tint vA = (int) data[1];\n\t\t\tut32 vB = (data[3] << 8) | data[2];\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t\top->val = vB;\n\t\t}\n\t\tbreak;\n\tcase 0x0a: // move-result\n\tcase 0x0d: // move-exception\n\tcase 0x0c: // move-result-object\n\tcase 0x0b: // move-result-wide\n\t \t// TODO: add MOVRET OP TYPE ??\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t{\n\t\t\tut32 vA = data[1];\n\t\t\tesilprintf (op, "sp,v%d,=[8],8,sp,+=,8", vA);\n\t\t}\n\t\tbreak;\n\tcase 0x1a: // const-string\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tif (len > 2) {\n\t\t\tut32 vA = data[1];\n\t\t\tut32 vB = (data[3]<<8) | data[2];\n\t\t\tut64 offset = R_ANAL_GET_OFFSET (anal, \'s\', vB);\n\t\t\top->ptr = offset;\n\t\t\tesilprintf (op, "0x%"PFMT64x",v%d,=", offset, vA);\n\t\t}\n\t\tbreak;\n\tcase 0x1c: // const-class\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tbreak;\n\tcase 0x85: // long-to-float\n\tcase 0x8e: // double-to-int\n\tcase 0x89: // float-to-double\n\tcase 0x8a: // double-to-int\n\tcase 0x87: // double-to-int\n\tcase 0x8c: // double-to-float\n\tcase 0x8b: // double-to-long\n\tcase 0x88: // float-to-long\n\tcase 0x86: // long-to-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x81: // int-to-long\n\tcase 0x82: // \n\tcase 0x83: // \n\tcase 0x84: // \n\tcase 0x8d: // int-to-byte\n\tcase 0x8f: // int-to-short\n\tcase 0x20: // instance-of\n\t\top->type = R_ANAL_OP_TYPE_CAST;\n\t\tbreak;\n\tcase 0x21: // array-length\n\t\top->type = R_ANAL_OP_TYPE_LENGTH;\n\t\tbreak;\n\tcase 0x44: // aget\n\tcase 0x45: //aget-bool\n\tcase 0x46:\n\tcase 0x47: //aget-bool\n\tcase 0x48: //aget-byte\n\tcase 0x49: //aget-char\n\tcase 0x4a: //aget-short\n\tcase 0x52: //iget\n\tcase 0x58: //iget-short\n\tcase 0x53: //iget-wide\n\tcase 0x56: //iget-byte\n\tcase 0x57: //iget-char\n\tcase 0xea: //sget-wide-volatile\n\tcase 0x63: //sget-boolean\n\tcase 0xf4: //iget-byte\n\tcase 0x66: //sget-short\n\tcase 0xfd: //sget-object\n\tcase 0x55: //iget-bool\n\tcase 0x60: // sget\n\tcase 0x61: // \n\tcase 0x62: //\n\tcase 0x64: // sget-byte\n\tcase 0x65: // sget-char\n\tcase 0xe3: //iget-volatile\n\tcase 0xe4: //\n\tcase 0xe5: // sget\n\tcase 0xe6: // sget\n\tcase 0x54: // iget-object\n\tcase 0xe7: // iget-object-volatile\n\tcase 0xe8: //iget-bool\n\tcase 0xf3: //iget-bool\n\tcase 0xf8: //iget-bool\n\tcase 0xf2: //iget-quick\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\tbreak;\n\tcase 0x6b: //sput-byte\n\tcase 0x6d: //sput-short\n\tcase 0xeb: //sput-wide-volatile\n\tcase 0x4b: //aput\n\tcase 0x4c: //aput-wide\n\tcase 0x4d: // aput-object\n\tcase 0x4e: // aput-bool\n\tcase 0x4f: // \n\tcase 0x5e: //iput-char\n\tcase 0xfc: //iput-object-volatile\n\tcase 0xf5: //iput-quick\n\tcase 0x5c: //iput-bool\n\tcase 0x69: //sput-object\n\tcase 0x5f: //iput-wide\n\tcase 0xe9: //iput-wide-volatile\n\tcase 0xf6: //iput-wide\n\tcase 0xf7: //iput-wide\n\tcase 0x67: //iput-wide\n\tcase 0x59: //iput-wide\n\tcase 0x5a: //iput-wide\n\tcase 0x5b: //iput-wide\n\tcase 0x5d: //iput-wide\n\tcase 0x50: //\n\tcase 0x51: // aput-short\n\tcase 0x68: // sput-wide\n\tcase 0x6a: // sput-boolean\n\tcase 0x6c: // sput-wide\n\tcase 0xfe: // sput\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t{\n\t\t\tut32 vA = (data[1] & 0x0f);\n\t\t\tut32 vB = (data[1] & 0xf0) >> 4;\n\t\t\tesilprintf (op, "v%d,v%d,=", vA, vB);\n\t\t}\n\t\tbreak;\n\tcase 0x9d:\n\tcase 0xad: // mul-double\n\tcase 0xc8: // mul-float\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* fall through */\n\tcase 0xcd:\n\tcase 0xd2:\n\tcase 0x92:\n\tcase 0xb2:\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\tbreak;\n\tcase 0x7c: // not-int\n\tcase 0x7e: // not-long\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\tbreak;\n\tcase 0xa4: // shr-long\n\tcase 0xba: // ushr-int/2addr\n\tcase 0xe2: // ushr-int\n\tcase 0xa5: // ushr-long\n\tcase 0x9a: // ushr-long\n\tcase 0xc5: // ushr-long/2addr\n\tcase 0xc4: // shr-long/2addr\n\tcase 0xe1: // shr-int/lit8\n\tcase 0x99: // shr-int\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tbreak;\n\tcase 0xaa: // rem-float\n\tcase 0xcf: // rem-double\n\tcase 0xaf: // rem-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0xb4: // rem-int/2addr\n\tcase 0xdc: // rem-int/lit8\n\tcase 0xd4: // rem-int\n\tcase 0xbf: // rem-long/2addr\n\tcase 0x9f: // rem-long\n\tcase 0x94: // rem-int\n\t\top->type = R_ANAL_OP_TYPE_MOD; // mod = rem\n\t\tbreak;\n\tcase 0xd7:\n\tcase 0xd9:\n\tcase 0xda:\n\tcase 0xde:\n\tcase 0xdf:\n\tcase 0x96:\n\tcase 0xc2: // xor-long\n\tcase 0x97: // xor-int\n\tcase 0xa2: // xor-long\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\tbreak;\n\tcase 0xc9: // div-float\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* pass thru */\n\tcase 0x93: // div-int\n\tcase 0xd3: // div-int/lit16\n\tcase 0xdb: // div-int/lit8\n\tcase 0xce: // div-double\n\tcase 0x9e: // div-double\n\tcase 0xbe: // div-double\n\tcase 0xae: // div-double\n\tcase 0xa9: // div-float\n\tcase 0xb3: // div-int/2addr\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\tbreak;\n\tcase 0x0e: // return-void\n\tcase 0x0f: // return\n\tcase 0x10: // return-wide\n\tcase 0x11: // return-object\n\tcase 0xf1: // return-void-barrier\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->eob = true;\n\t\t//TODO: handle return if(0x0e) {}\xa0else {}\n\t\tif (data[0] == 0x0e) {// return-void\n\t\t\tesilprintf (op, "sp,[8],ip,=,8,sp,+=");\n\t\t} else {\n\t\t\tut32 vA = data[1];\n\t\t\tesilprintf (op, "sp,[8],ip,=,8,sp,+=,8,sp,-=,v%d,sp,=[8]", vA);\n\t\t}\n\t\tbreak;\n\tcase 0x28: // goto\n\t\top->jump = addr + ((char)data[1])*2;\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\top->eob = true;\n\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\tbreak;\n\tcase 0x29: // goto/16\n\t\tif (len > 2) {\n\t\t\top->jump = addr + (short)(data[2]|data[3]<<8)*2;\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\top->eob = true;\n\t\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\t}\n\t\tbreak;\n\tcase 0x2a: // goto/32\n\t\tif (len > 2) {\n\t\t\top->jump = addr + (int)(data[2]|(data[3]<<8)|(data[4]<<16)|(data[5]<<24))*2;\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\top->eob = true;\n\t\t\tesilprintf (op, "0x%"PFMT64x",ip,=", op->jump);\n\t\t}\n\t\tbreak;\n\tcase 0x2c:\n\tcase 0x2b:\n\t\top->type = R_ANAL_OP_TYPE_SWITCH;\n\t\tbreak;\n\tcase 0x2d: // cmpl-float\n\tcase 0x2e: // cmpg-float\n\tcase 0x3f: // cmpg-float // ???? wrong disasm imho 2e0f12003f0f\n\tcase 0x2f: // cmpl-double\n\tcase 0x30: // cmlg-double\n\tcase 0x31: // cmp-long\n\tcase 0x1f: // check-cast\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\tbreak;\n\tcase 0x32: // if-eq\n\tcase 0x33: // if-ne\n\tcase 0x34: // if-lt\n\tcase 0x35: // if-ge\n\tcase 0x36: // if-gt\n\tcase 0x37: // if-le\n\tcase 0x38: // if-eqz\n\tcase 0x39: // if-nez\n\tcase 0x3a: // if-ltz\n\tcase 0x3b: // if-gez\n\tcase 0x3c: // if-gtz\n\tcase 0x3d: // if-lez\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t//XXX fix this better the check is to avoid an oob\n\t\tif (len > 2) {\n\t\t\top->jump = addr + (len>3?(short)(data[2]|data[3]<<8)*2 : 0);\n\t\t\top->fail = addr + sz;\n\t\t\top->eob = true;\n\t\t}\n\t\tbreak;\n\tcase 0xec: // breakpoint\n\tcase 0x1d: // monitor-enter\n\t\top->type = R_ANAL_OP_TYPE_UPUSH;\n\t\tbreak;\n\tcase 0x1e: // monitor-exit /// wrong type?\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\tbreak;\n\tcase 0x6f: // invoke-super\n\tcase 0xfa: // invoke-super-quick\n\tcase 0x70: // invoke-direct\n\tcase 0x71: // invoke-static\n\tcase 0x72: // invoke-interface\n\tcase 0x73: //\n\tcase 0x74: //\n\tcase 0x75: //\n\tcase 0x76: // invoke-direct\n\tcase 0x77: //\n\tcase 0x78: // invokeinterface/range\n\tcase 0xb9: // invokeinterface\n\tcase 0xb7: // invokespecial\n\tcase 0xb8: // invokestatic\n\tcase 0xb6: // invokevirtual\n\tcase 0x6e: // invoke-virtual\n\tcase 0xf0: // invoke-object-init-range\n\tcase 0xf9: // invoke-virtual-quick/range\n\tcase 0xfb: // invoke-super-quick/range\n\t\tif (len > 2) {\n\t\t\t//XXX fix this better since the check avoid an oob\n\t\t\t//but the jump will be incorrect\n\t\t\tut32 vB = len > 3?(data[3] << 8) | data[2] : 0;\n\t\t\top->jump = anal->binb.get_offset (anal->binb.bin, \'m\', vB);\n\t\t\top->fail = addr + sz;\n\t\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\t\t// TODO: handle /range instructions\n\t\t\tesilprintf (op, "8,sp,-=,0x%"PFMT64x",sp,=[8],0x%"PFMT64x",ip,=", addr);\n\t\t}\n\t\tbreak;\n\tcase 0x27: // throw\n\tcase 0xee: // execute-inline\n\tcase 0xef: // execute-inline/range\n\tcase 0xed: // throw-verification-error\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\tbreak;\n#if 0\n\tcase 0xbb: // new\n\tcase 0xbc: // newarray\n\tcase 0xc5: // multi new array\n#endif\n\tcase 0x22: // new-instance\n\tcase 0x23: // new-array\n\tcase 0x24: // filled-new-array\n\tcase 0x25: // filled-new-array-range\n\tcase 0x26: // filled-new-array-data\n\t\top->type = R_ANAL_OP_TYPE_NEW;\n\t\t// 0x1c, 0x1f, 0x22\n\t\tif (len > 2) {\n\t\t\t//int vA = (int) data[1];\n\t\t\tint vB = (data[3] << 8) | data[2];\n\t\t\t// resolve class name for vB\n\t\t\tut64 off = R_ANAL_GET_OFFSET (anal, \'t\', vB);\n\t\t\top->ptr = off;\n\t\t}\n\t\tbreak;\n\tcase 0x00: // nop\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\tbreak;\n\tcase 0x90: // add-int\n\tcase 0x9b: // add-long\n\tcase 0xa6: // add-float\n\tcase 0xac: // add-double\n\tcase 0xb0: // add-int/2addr\n\tcase 0xbb: // add-long/2addr\n\tcase 0xc6: // add-float/2addr\n\tcase 0xcb: // add-double/2addr\n\tcase 0xd0: // add-int/lit16\n\tcase 0xd8: // add-int/lit8\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tbreak;\n\tcase 0xa7: // sub-float\n\tcase 0xcc: //sub-double\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\t/* fall thru */\n\tcase 0xc7:\n\tcase 0xbc:\n\tcase 0x91:\n\tcase 0xb1: //sub-int/2addr\n\tcase 0xd1: //sub-int/2addr\n\tcase 0x9c: //sub-long\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\tbreak;\n\tcase 0x7b: // neg-int\n\tcase 0x7d: // neg-long\n\tcase 0x7f: // neg-float\n\tcase 0x80: // neg-double\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\tbreak;\n\tcase 0xa0: // and-long\n\tcase 0xc0: // and-long\n\tcase 0xdd: // and-long\n\tcase 0xd5: // and-long\n\tcase 0x95:\n\tcase 0xb5: // and-int\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\tbreak;\n\tcase 0xd6: // orint/lit16\n\tcase 0xc1: // or-long/2addr\n\tcase 0xa1: // or-long\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\tbreak;\n\tcase 0xe0: //lshl\n\tcase 0xc3: //lshl\n\tcase 0xa3: // shl-long\n\tcase 0x98: // shl-long\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tbreak;\n\t}\n\n\teturn sz;\n\n}'}
    pre_simp, post_simp = filter_code_blocks(dict1['func_before'], dict1['func'], dict1['delete_slice'], parser_c)
    print('delete_slice', dict1['delete_slice'])
    print(dict1['func_before'], '\n\n', dict1['func'], '\n\n')
    print('pre_simp', len(pre_simp.split('\n')))
    # print(pre_simp, '\n\n', post_simp)
    # print((dict1['func_before']),'\n\n', (dict1['pre_function_simplication']))
    print(len(dict1['pre_function_simplication'].split('\n')), len(dict1['func_before'].split('\n')))
